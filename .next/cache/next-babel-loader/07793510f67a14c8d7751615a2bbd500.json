{"ast":null,"code":"/**\n * chartjs-plugin-gridline-background.js\n * version 1.0\n */\nfunction getLineValue(scale, index, offsetGridLines) {\n  var lineValue = scale.getPixelForTick(index);\n\n  if (offsetGridLines) {\n    if (index === 0) {\n      lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n    }\n  }\n\n  return lineValue;\n} // Setup defaults; this will draw one fully transparent rectangle for each axis.\n// So, if the user only includes the plugin, but sets no configuration,\n// (s)he won't see any difference.\n\n\nthis.Chart.defaults.global.plugins.gridBgColor = {\n  backgroundColorRepeat: false,\n  backgroundColor: 'rgba(127,127,127,0.0)'\n};\nvar plugin = {\n  id: 'gridBgColor',\n  beforeDraw: function beforeDraw(chartInstance) {\n    // This is what the plugin does.\n    //\n    //\t\tfor (scales) {\n    //\t\t\tfor (gridLines) {\n    //\t\t\t\tif (isarray(backgroundColor)) {\n    //\t\t\t\t\tdraw the grindline background\n    //\t\t\t\t} else { if (isString(backgroundColor)) {\n    //\t\t\t\t\t\t\t\tdraw the background for the whole axis, thus for the chartArea\n    //\t\t\t\t\t\t }\n    //\t\t\t\t}\n    //\t\t\t}\n    //\t\t}\n    var ctx = chartInstance.chart.ctx;\n    var canvas = chartInstance.chart.canvas;\n    var chartArea = chartInstance.chartArea;\n    var scale;\n    var si;\n    var ti;\n    var bgCol = [],\n        bgColRpt;\n    var x1, y1, x2, y2;\n    var axisWidth;\n    var isHorizontal;\n    var scaleType;\n    var gridLines;\n    var lineWidth;\n\n    for (si in chartInstance.scales) {\n      scale = chartInstance.scales[si];\n      axisWidth = scale.options.gridLines.lineWidth;\n      isHorizontal = scale.isHorizontal();\n      scaleType = scale.options.type;\n      gridLines = chartInstance.scales[si].options.gridLines;\n      lineWidth = gridLines.lineWidth;\n      bgCol = scale.options.gridLines.backgroundColor;\n      bgCol = bgCol == undefined ? chartInstance.chart.options.plugins.gridBgColor.backgroundColor : bgCol;\n      bgColRpt = scale.options.gridLines.backgroundColorRepeat;\n      bgColRpt = bgColRpt == undefined ? chartInstance.chart.options.plugins.gridBgColor.backgroundColorRepeat : bgColRpt;\n\n      if (!scale.options.display || bgCol == undefined) {\n        // No background coloring for this scale; next scale.\n        continue;\n      }\n\n      ;\n\n      if (typeof bgCol === 'string') {\n        // One color for the complete scale background.\n        // One rectangle for the chart area.\n        ctx.fillStyle = bgCol;\n        ctx.fillRect(chartArea.left, chartArea.bottom, chartArea.right - chartArea.left, chartArea.top - chartArea.bottom);\n        continue; // next scale\n      }\n\n      ;\n\n      if (bgCol.constructor === Array) {\n        // Color the individual gridline backgrounds.\n        // Algorithm in essence:\n        // Loop through the gridLines (ticks),\n        //\t If backgroundColor is different from previous,\n        //\t\t draw the background rectangle and \n        //\t\t save the new coordinates as the start of the next rectangle\n        // A simpler algorithm would be to draw each gridLine's background individually,\n        // but I got overlaps and gaps (of 1 pixel width), so that was too ugly.\n        // Plus, this one is more efficient, as it draws less background rectangles.\n        var prevTick = {\n          bgCol: '',\n          x1: 0,\n          y1: 0,\n          x2: 0,\n          y2: 0\n        };\n        var curBgCol;\n        var numToDo = scale.ticks.length - (scaleType != 'category' ? 1 : 0);\n\n        for (ti = 0; ti <= numToDo; ti++) {\n          // Note: this does one extra tick!\n          ti = Number(ti);\n\n          if (ti == numToDo) {\n            // This is the last gridline, make sure we draw it.\n            // Also, there probably is no more bgCol[ti]\n            curBgCol = 'differentFromPrevious';\n          } else {\n            // Repeat the bgColors if necessary.\n            if (bgColRpt) {\n              curBgCol = bgCol[ti % bgCol.length];\n            } else {\n              curBgCol = bgCol[ti];\n            }\n\n            ;\n          }\n\n          ;\n\n          if (curBgCol != prevTick.bgCol) {\n            // Some code copied from Chart.js scale.\n            if (isHorizontal) {\n              // Vertical grid line / grid background\n              var xLineValue = getLineValue(scale, ti, gridLines.offsetGridLines && scale.ticks.length > 1);\n              xLineValue += lineWidth % 2 === 0 ? 0 : 0.5;\n              x1 = x2 = xLineValue;\n              y1 = chartArea.top;\n              y2 = chartArea.bottom + axisWidth;\n            } else {\n              // Horizontal grid line\n              var yLineValue = getLineValue(scale, ti, gridLines.offsetGridLines && scale.ticks.length > 1);\n              yLineValue += lineWidth % 2 === 0 ? 0 : 0.5;\n              x1 = chartArea.left;\n              x2 = chartArea.right + axisWidth;\n              y1 = y2 = yLineValue;\n            }\n\n            ;\n\n            if (gridLines.drawOnChartArea && prevTick.bgCol != '') {\n              ctx.save();\n              ctx.fillStyle = prevTick.bgCol;\n\n              if (isHorizontal) {\n                // Horizontal scale, vertical grid line / grid background\n                ctx.fillRect(prevTick.x1, prevTick.y1, Math.abs(x2 - prevTick.x1), Math.abs(y2 - prevTick.y1));\n              } else {\n                // Horizontal grid line\n                ctx.fillRect(prevTick.x1, prevTick.y1, Math.abs(x2 - prevTick.x1), Math.abs(y2 - prevTick.y1));\n              }\n\n              ;\n            }\n\n            ; // gl.drawonChartArea\n\n            ctx.restore(); // Save the new coordinates\n\n            prevTick.bgCol = curBgCol;\n            prevTick.x1 = x1;\n            prevTick.y1 = y1;\n            prevTick.x2 = x2;\n            prevTick.y2 = y2;\n          }\n\n          ; // bgCol != bgCol\n        }\n\n        ; //for ti in ticks\n\n        continue;\n      }\n\n      ; // if bgCol is of type array\n      // If we get here, that's an error!\n\n      console.log(\"chartjs-plugin-gridline-background.js: Error, unknown type of backgroundColor (not String or Array): \" + bgCol);\n    }\n\n    ; // for si\n  } // beforeDraw: function\n\n}; // plugin\n\nChart.plugins.register(plugin);","map":{"version":3,"sources":["/Users/raypo/Desktop/Projectos/CoronaStatus/utils/gridLineBg.js"],"names":["getLineValue","scale","index","offsetGridLines","lineValue","getPixelForTick","Chart","defaults","global","plugins","gridBgColor","backgroundColorRepeat","backgroundColor","plugin","id","beforeDraw","chartInstance","ctx","chart","canvas","chartArea","si","ti","bgCol","bgColRpt","x1","y1","x2","y2","axisWidth","isHorizontal","scaleType","gridLines","lineWidth","scales","options","type","undefined","display","fillStyle","fillRect","left","bottom","right","top","constructor","Array","prevTick","curBgCol","numToDo","ticks","length","Number","xLineValue","yLineValue","drawOnChartArea","save","Math","abs","restore","console","log","register"],"mappings":"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","sourcesContent":["/**\n * chartjs-plugin-gridline-background.js\n * version 1.0\n */\n\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\n// Setup defaults; this will draw one fully transparent rectangle for each axis.\n// So, if the user only includes the plugin, but sets no configuration,\n// (s)he won't see any difference.\nthis.Chart.defaults.global.plugins.gridBgColor = {\n\tbackgroundColorRepeat: false,\n\tbackgroundColor: 'rgba(127,127,127,0.0)',\n}\n\nconst plugin = {\n\tid: 'gridBgColor',\n\n\tbeforeDraw: function (chartInstance) {\n\n\t\t// This is what the plugin does.\n\t\t//\n\t\t//\t\tfor (scales) {\n\t\t//\t\t\tfor (gridLines) {\n\t\t//\t\t\t\tif (isarray(backgroundColor)) {\n\t\t//\t\t\t\t\tdraw the grindline background\n\t\t//\t\t\t\t} else { if (isString(backgroundColor)) {\n\t\t//\t\t\t\t\t\t\t\tdraw the background for the whole axis, thus for the chartArea\n\t\t//\t\t\t\t\t\t }\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\n\t\tconst ctx = chartInstance.chart.ctx;\n\t\tconst canvas = chartInstance.chart.canvas;\n\t\tconst chartArea = chartInstance.chartArea;\n\n\t\tvar scale;\n\t\tvar si;\n\t\tvar ti;\n\t\tvar bgCol = [], bgColRpt;\n\t\tvar x1, y1, x2, y2;\n\t\tvar axisWidth;\n\t\tvar isHorizontal;\n\t\tvar scaleType;\n\t\tvar gridLines;\n\t\tvar lineWidth;\n\n\t\tfor (si in chartInstance.scales) {\n\t\t\tscale = chartInstance.scales[si];\n\t\t\taxisWidth = scale.options.gridLines.lineWidth;\n\t\t\tisHorizontal = scale.isHorizontal();\n\t\t\tscaleType = scale.options.type;\n\t\t\tgridLines = chartInstance.scales[si].options.gridLines;\n\t\t\tlineWidth = gridLines.lineWidth;\n\t\t\tbgCol = scale.options.gridLines.backgroundColor;\n\t\t\tbgCol = ( bgCol == undefined ? chartInstance.chart.options.plugins.gridBgColor.backgroundColor : bgCol );\n\t\t\tbgColRpt = scale.options.gridLines.backgroundColorRepeat;\n\t\t\tbgColRpt = ( bgColRpt == undefined ? chartInstance.chart.options.plugins.gridBgColor.backgroundColorRepeat : bgColRpt );\n\n\t\t\tif (!scale.options.display || bgCol == undefined) {\n\t\t\t\t// No background coloring for this scale; next scale.\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tif (typeof bgCol === 'string') {\n\t\t\t\t// One color for the complete scale background.\n\t\t\t\t// One rectangle for the chart area.\n\t\t\t\tctx.fillStyle = bgCol;\n\t\t\t\tctx.fillRect(chartArea.left, chartArea.bottom\n\t\t\t\t\t, chartArea.right - chartArea.left, chartArea.top - chartArea.bottom);\n\t\t\t\tcontinue; // next scale\n\t\t\t};\n\n\t\t\tif (bgCol.constructor === Array) {\n\n\t\t\t\t// Color the individual gridline backgrounds.\n\t\t\t\t// Algorithm in essence:\n\t\t\t\t// Loop through the gridLines (ticks),\n\t\t\t\t//\t If backgroundColor is different from previous,\n\t\t\t\t//\t\t draw the background rectangle and \n\t\t\t\t//\t\t save the new coordinates as the start of the next rectangle\n\t\n\t\t\t\t// A simpler algorithm would be to draw each gridLine's background individually,\n\t\t\t\t// but I got overlaps and gaps (of 1 pixel width), so that was too ugly.\n\t\t\t\t// Plus, this one is more efficient, as it draws less background rectangles.\n\t\n\t\t\t\tvar prevTick= {\n\t\t\t\t\tbgCol: '',\n\t\t\t\t\tx1: 0,\n\t\t\t\t\ty1: 0,\n\t\t\t\t\tx2: 0,\n\t\t\t\t\ty2: 0,\n\t\t\t\t};\n\t\t\t\tvar curBgCol;\n\t\t\t\tvar numToDo = scale.ticks.length - (scaleType != 'category' ? 1 : 0);\n\t\n\t\t\t\tfor (ti=0; ti<=numToDo; ti++) { // Note: this does one extra tick!\n\t\n\t\t\t\t\tti = Number(ti);\n\t\n\t\t\t\t\tif (ti == numToDo) {\n\t\t\t\t\t\t// This is the last gridline, make sure we draw it.\n\t\t\t\t\t\t// Also, there probably is no more bgCol[ti]\n\t\t\t\t\t\tcurBgCol = 'differentFromPrevious';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Repeat the bgColors if necessary.\n\t\t\t\t\t\tif (bgColRpt) {\n\t\t\t\t\t\t\tcurBgCol = bgCol[ti % bgCol.length];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurBgCol = bgCol[ti];\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\n\t\t\t\t\tif ( curBgCol != prevTick.bgCol ) {\n\t\t\t\t\t\t// Some code copied from Chart.js scale.\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t// Vertical grid line / grid background\n\t\t\t\t\t\t\tvar xLineValue = getLineValue(scale, ti, gridLines.offsetGridLines && scale.ticks.length > 1);\n\t\t\t\t\t\t\txLineValue += (lineWidth % 2 === 0) ? 0 : 0.5;\n\t\t\t\t\t\t\tx1 = x2 = xLineValue;\n\t\t\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Horizontal grid line\n\t\t\t\t\t\t\tvar yLineValue = getLineValue(scale, ti, gridLines.offsetGridLines && scale.ticks.length > 1);\n\t\t\t\t\t\t\tyLineValue += (lineWidth % 2 === 0) ? 0 : 0.5;\n\t\t\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\t\t\ty1 = y2 = yLineValue;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (gridLines.drawOnChartArea && prevTick.bgCol != '') {\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.fillStyle = prevTick.bgCol;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\t// Horizontal scale, vertical grid line / grid background\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tprevTick.x1, prevTick.y1,\n\t\t\t\t\t\t\t\t\tMath.abs(x2 - prevTick.x1), Math.abs(y2 - prevTick.y1)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Horizontal grid line\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tprevTick.x1, prevTick.y1,\n\t\t\t\t\t\t\t\t\tMath.abs(x2 - prevTick.x1), Math.abs(y2 - prevTick.y1)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}; // gl.drawonChartArea\n\t\t\t\t\t\tctx.restore();\n\t\n\t\t\t\t\t\t// Save the new coordinates\n\t\t\t\t\t\tprevTick.bgCol = curBgCol;\n\t\t\t\t\t\tprevTick.x1 = x1;\n\t\t\t\t\t\tprevTick.y1 = y1;\n\t\t\t\t\t\tprevTick.x2 = x2;\n\t\t\t\t\t\tprevTick.y2 = y2;\n\t\t\t\t\t\t\n\t\t\t\t\t}; // bgCol != bgCol\n\t\n\t\t\t\t}; //for ti in ticks\n\t\n\t\t\t\t\tcontinue;\n\t\t\t}; // if bgCol is of type array\n\n\t\t\t// If we get here, that's an error!\n\t\t\tconsole.log(\"chartjs-plugin-gridline-background.js: Error, unknown type of backgroundColor (not String or Array): \" + bgCol);\n\n\t\t}; // for si\n\n\t} // beforeDraw: function\n} // plugin\n\nChart.plugins.register(plugin);\n"]},"metadata":{},"sourceType":"script"}